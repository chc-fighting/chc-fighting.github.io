<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8"> 
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="亦文梦之" />
        <meta name="copyright" content="亦文梦之" />

<meta name="keywords" content="PAT 编程 数据结构 C语言, 编程, " />
        <title>PAT-数据结构学习与实验指导-1  · 随风飘飘
</title>
        <link href="http://cdn-images.mailchimp.com/embedcode/slim-081711.css" rel="stylesheet" type="text/css">
        <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/css/bootstrap-combined.min.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="http://chc-fighting.github.io/theme/css/style.css" media="screen">
        <link rel="stylesheet" type="text/css" href="http://chc-fighting.github.io/theme/css/solarizedlight.css" media="screen">
        <link rel="shortcut icon" href="http://chc-fighting.github.io/theme/images/favicon.ico" type="image/x-icon" />
        <link rel="apple-touch-icon" href="http://chc-fighting.github.io/theme/images/apple-touch-icon.png" />
        <link rel="apple-touch-icon" sizes="57x57" href="http://chc-fighting.github.io/theme/images/apple-touch-icon-57x57.png" />
        <link rel="apple-touch-icon" sizes="72x72" href="http://chc-fighting.github.io/theme/images/apple-touch-icon-72x72.png" />
        <link rel="apple-touch-icon" sizes="114x114" href="http://chc-fighting.github.io/theme/images/apple-touch-icon-114x114.png" />
        <link rel="apple-touch-icon" sizes="144x144" href="http://chc-fighting.github.io/theme/images/apple-touch-icon-144x144.png" />
        <link rel="icon" href="http://chc-fighting.github.io/theme/images/apple-touch-icon-144x144.png" />
        <link href="http://chc-fighting.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="随风飘飘 - Full Atom Feed" />
        <link href="http://chc-fighting.github.io/feeds\编程.atom.xml" type="application/atom+xml" rel="alternate" title="随风飘飘 - 编程 Category Atom Feed" />
        <link href="http://chc-fighting.github.io/feeds\编程之美.atom.xml" type="application/atom+xml" rel="alternate" title="随风飘飘 - 编程之美 Category Atom Feed" />
        <link href="http://chc-fighting.github.io/feeds\个人生活.atom.xml" type="application/atom+xml" rel="alternate" title="随风飘飘 - 个人生活 Category Atom Feed" />
    </head>
    <body>
        <div id="content-sans-footer">
        <div class="navbar navbar-static-top">
            <div class="navbar-inner">
                <div class="container">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <a class="brand" href="http://chc-fighting.github.io/"><span class=site-name>随风飘飘</span></a>
                    <div class="nav-collapse collapse">
                        <ul class="nav pull-right top-menu">
                            <li ><a href="http://chc-fighting.github.io">Home</a></li>
                            <li ><a href="http://chc-fighting.github.io/categories.html">Categories</a></li>
                            <li ><a href="http://chc-fighting.github.io/tags.html">Tags</a></li>
                            <li ><a href="http://chc-fighting.github.io/archives.html">Archives</a></li>
                            <li><form class="navbar-search" action="http://chc-fighting.github.io/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="container-fluid">
            <div class="row-fluid">
                <div class="span1"></div>
                <div class="span10">
<article>
<div class="row-fluid">
    <header class="page_header span10 offset2">
    <h1><a href="http://chc-fighting.github.io/wjj-1.html"> PAT-数据结构学习与实验指导-1  </a></h1>
    </header>
</div>

<div class="row-fluid">
        <div class="span8 offset2 article-content">

            <p>PAT(Programming Ability Test)网址 <a href="http://pat.zju.edu.cn/contests/ds/">http://pat.zju.edu.cn/contests/ds</a></p>
<p>或者参见我CSDN上的博客文章 <a href = "http://blog.csdn.net/wutongyu0113/article/">http://blog.csdn.net/wutongyu0113/article/</a></p>
<p>关于这一部分的题目网上有很多人都给出过解答方法和源码，但大都是以C++完成的，因为C++简单方便。自己当时一心想着先提高C的编程能力再去学习C++，所以一直坚持用C来解决数据结构的问题，虽然没有C++模板类那么方便，很多时候需要自己去定义一些结构体和函数，但这有利于对数据结构内部机理的掌握。</p>
<p>下面给出部分题目的答案，还有部分题目自己没有AC，所以暂不放上来了。</p>
<h2 id="2-06">2-06 数列求和</h2>
<p>题目描述：</p>
<p>给定某数字A（1&lt;=A&lt;=9）以及非负整数N（0&lt;=N&lt;=100000），求数列之和S = A + AA + AAA + … + AA…A(N个A)。例如A=1, N=3时，S = 1 + 11 + 111 = 123。</p>
<p>输入格式说明：</p>
<p>输入数字A与非负整数N。</p>
<p>输出格式说明：</p>
<p>输出其N项数列之和S的值。</p>
<p>解答说明：</p>
<p>由于和S特别大，所以不可能直接求和计算，否则肯定会运行超时或者内存超限。
可以把求和写成算式的形式
如A+AA+AAA写成
    AAA
      AA
        A
这样和的个位肯定是A<em>3%10，十位肯定是(A</em>2+A*3/10)%10，以此类推。
可以用堆栈保存每一位的结果，最后再输出即可。</p>
<h3 id="_1">源码：</h3>
<pre><code>
#include"stdio.h"
#include"stdlib.h"

typedef struct Node *ptrNode;
typedef ptrNode stack;
typedef int ElementType;

struct Node{
   ElementType Element;
   ptrNode next;
};


/*检验是否空栈*/
int IsEmpty(stack S)
{
  return S->next == NULL;
}
/*销毁一个站，置空*/
void MakeEmpty(stack S)
{
   if(S == NULL){
        printf("stack is already empty");
        exit(0);
    }
    else
        while(!IsEmpty(S))
            popAndReturnTop(S);
}

stack Createstack(void)
{
    stack S;

    if((S = malloc(sizeof(struct Node))) == NULL){//不要少了括号！！！
        printf("Unable to allocate memory");
        exit(0);
    }
    S->next = NULL;
    MakeEmpty(S);
    return S;
}

void push(ElementType x, stack S)
{
    ptrNode TmpCell;
    TmpCell = malloc(sizeof(struct Node));
    TmpCell->Element = x;
    TmpCell->next = S->next;
    S->next = TmpCell;
}

ElementType popAndReturnTop(stack S)
{
    ptrNode TmpCell;
    ElementType TopElement;
    if(S == NULL){
        printf("Empty stack");
        exit(0);
    }
    else{
        TmpCell = S->next;
        S->next = S->next->next;
        TopElement = TmpCell->Element;
        free(TmpCell);
    }
    return TopElement;
}


int main(void)
{
    int A, N;
    int i,m,n,carry,temp;
    stack s;

    s = Createstack();

    scanf("%d%d",&A,&N);
    if(N == 0)
        printf("0");
    carry = 0;
    for(i = N; i>0;i--){
        n = i * A + carry;
        m = n % 10;
        carry = n / 10;
        if(i != 1)
            push(m,s);
        else
            push(n,s);
    }
    while(!IsEmpty(s)){
        temp = popAndReturnTop(s);
        printf("%d",temp);
    }
    return 0;
}

</code></pre>

<h2 id="2-07">2-07 素因子分解</h2>
<p>题目说明：</p>
<p>给定某个正整数N，求其素因子分解结果，即给出其因式分解表达式 N = p1^k1 * p2^k2 <em>…</em>pm ^km。</p>
<p>输入格式说明：</p>
<p>输入long int范围内的正整数N。</p>
<p>输出格式说明：</p>
<p>按给定格式输出N的素因式分解表达式，即 N = p1^k1 * p2^k2 <em>…</em>pm ^km，其中pi为素因子并要求由小到大输出，指数ki为pi的个数；当ki==1即因子pi只有一个时不输出ki。</p>
<p>解答说明：
从小到大依次寻找素因子，并对每一个素因子的个数做统计。</p>
<h3 id="_2">源码：</h3>
<pre><code>
#include"stdio.h"
#include"math.h"

int main(void)
{
    int i,j;
    long int m, n;
    int count;
    int isPrime,flag;

    isPrime = 1;
    flag = 0;

    scanf("%ld",&n);
    printf("%ld=",n);
    m = sqrt(n);
    for(i = 2; i <= m;i++){
        if(n%i == 0){
            //printf("%d",i);
            isPrime = 0;
            count = 1;
            n = n / i;
            while(n%i == 0){
                n = n / i;
                count++;
            }
            if(flag)
                printf("*");
            else
                flag = 1;
            if(count == 1)
                printf("%d",i);
            else
                printf("%d^%d",i,count);
        }
    }
    if(isPrime)
        printf("%d",n);

    return 0;
}

</code></pre>

<h2 id="2-08-24">2-08  用扑克牌计算24点</h2>
<p>题目描述：</p>
<p>一副扑克牌的每张牌表示一个数（J、Q、K分别表示11、12、13，两个司令都表示6）。任取4张牌，即得到4个1~13的数，请添加运算符（规定为加+ 减- 乘* 除/ 四种）使之成为一个运算式。每个数只能参与一次运算，4个数顺序可以任意组合，4个运算符任意取3个且可以重复取。运算遵从一定优先级别，可加括号控制，最终使运算结果为24。请输出一种解决方案的表达式，用括号表示运算优先。如果没有一种解决方案，则输出-1表示无解。</p>
<p>输入格式说明：</p>
<p>输入在一行中给出4个整数，每个整数取值在[1, 13]。</p>
<p>输出格式说明：</p>
<p>输出一种解决方案的表达式，用括号表示运算优先。如果没有解决方案，请输出-1。</p>
<p>解答说明：</p>
<p>四个操作数，三个操作符，两个括号，有以下五种计算模式</p>
<p>((A op B) op C) op D</p>
<p>(A op (B op C)) op D</p>
<p>A op (B op (C op D))</p>
<p>A op ((B op C) op D)</p>
<p>(A op B) op (C op D)</p>
<p>将每一种模式写成函数，最后采用穷举法找到计算结果为24的算式。</p>
<h3 id="_3">源码：</h3>
<pre><code>
//注意要在输出结果后面加\n，不然会有格式错误，坑爹啊!!!
#include"stdio.h"
#include"stdlib.h"

char op[5]={'#','+','-','*','/',};

float cal(float x,float y,int op)
{
  switch(op)
  {
    case 1:return x+y;
    case 2:return x-y;
    case 3: return x*y;
    case 4: return x/y;
  }
}

float calculate_model1(float i,float j,float k,float t,int op1,int op2,int op3)
{
  float r1,r2,r3;
  r1 = cal(i,j,op1);
  r2 = cal(r1,k,op2);
  r3 = cal(r2,t,op3);
  return r3;
}

float calculate_model2(float i,float j,float k,float t,int op1,int op2,int op3)
{
  float r1,r2,r3;
  r1 = cal(j,k,op2);
  r2 = cal(i,r1,op1);
  r3 = cal(r2,t,op3);
  return r3;
}

float calculate_model3(float i,float j,float k,float t,int op1,int op2,int op3)
{
  float r1,r2,r3 ;
  r1 = cal(k,t,op3);
  r2 = cal(j,r1,op2);
  r3 = cal(i,r2,op1);
  return r3;
}


float calculate_model4(float i,float j,float k,float t,int op1,int op2,int op3)
{
  float r1,r2,r3;
  r1 = cal(j,k,op2);
  r2 = cal(r1,t,op3);
  r3 = cal(i,r2,op1);
  return r3;
}

float calculate_model5(float i,float j,float k,float t,int op1,int op2,int op3)
{
  float r1,r2,r3 ;
  r1 = cal(i,j,op1);
  r2 = cal(k,t,op3);
  r3 = cal(r1,r2,op2);
  return r3;
}

int get24(int i,int j,int k,int t)
{
    int op1,op2,op3;
    int flag=0;
    for(op1=1;op1<=4;op1++)
        for(op2=1;op2<=4;op2++)
            for(op3=1;op3<=4;op3++)
            {
               if(calculate_model1(i,j,k,t,op1,op2,op3)==24){
                   printf("((%d%c%d)%c%d)%c%d\n",i,op[op1],j,op[op2],k,op[op3],t);flag = 1;goto OUT;
               }
               if(calculate_model2(i,j,k,t,op1,op2,op3)==24){
                   printf("(%d%c(%d%c%d))%c%d\n",i,op[op1],j,op[op2],k,op[op3],t);flag = 1;goto OUT;
               }
               if(calculate_model3(i,j,k,t,op1,op2,op3)==24){
                   printf("%d%c(%d%c(%d%c%d))\n",i,op[op1],j,op[op2],k,op[op3],t);flag = 1;goto OUT;
               }
               if(calculate_model4(i,j,k,t,op1,op2,op3)==24){
                   printf("%d%c((%d%c%d)%c%d)\n",i,op[op1],j,op[op2],k,op[op3],t);flag = 1;goto OUT;
               }
               if(calculate_model5(i,j,k,t,op1,op2,op3)==24){
                   printf("(%d%c%d)%c(%d%c%d)\n",i,op[op1],j,op[op2],k,op[op3],t);flag = 1;goto OUT;
               }
            }

OUT:    return flag;
}

int main()
{
    int x,y,m,n;
    int i,j,k,t;
    int in[4];
    int flag;
    for(i=0;i<4;i++)
        scanf("%d",&in[i]);
    for(i=0;i<4;i++){
        for(j=0;j<4;j++){
            if(j==i) continue;
            for(k=0;k<4;k++){
                if(i==k||j==k) continue;
                for(t=0;t<4;t++){
                    if(t==i||t==j||t==k) continue;
                    x = in[i];
                    y = in[j];
                    m = in[k];
                    n = in[t];
                    flag = get24(x,y,m,n);
                    if(flag ==1) goto END;
                }
            }
        }
    }
    if(flag == 0)
     printf("-1\n");

 END:   return 0;
}

</code></pre>

<h2 id="2-09">2-09 装箱问题模拟</h2>
<p>题目描述：
假设有N项物品，大小分别为s1, s2, …, si, …, sN，其中si为满足1&lt;= si&lt;=100的整数。要把这些物品装入到容量为100的一批箱子（序号1～N）中。装箱方法是：对每项物品, 顺序扫描箱子，把该物品放入足以能够容下它的第一个箱子中。请写一个程序模拟这种装箱过程，并输出每个物品所在的箱子序号，以及放置全部物品所需的箱子数目。</p>
<p>输入格式说明：</p>
<p>输入第1行给出物品个数N(&lt;=1000)，第2行给出N个正整数si（1 &lt;= si &lt;= 100，表示第i项物品的大小）。</p>
<p>输出格式说明：</p>
<p>按照输入顺序输出每个物品的大小及其所在的箱子序号，每个物品占1行，最后一行输出所需的箱子数目。</p>
<p>解答说明：
针对每一项物品，顺序扫描箱子，如果箱子能放得下，记录该物品所在的箱子，并将该箱子的容量更新。</p>
<h3 id="_4">源码：</h3>
<pre><code>
#include"stdio.h"

int main(void)
{
    int n;
    int *p,*q;
    int i,j,maxCount;


    scanf("%d",&n);
    p = (int*)malloc(n*sizeof(int));
    q = (int*)malloc(n*sizeof(int));
    for(i=0;i<n;i++)
        scanf("%d",&(*(p+i)));
    for(i=0;i<n;i++)
        *(q+i) = 100;
    maxCount = 1;
    for(i=0;i<n;i++){
        j = 1;
        while(1){
            if(*(q+j-1) >= *(p+i)){
                *(q+j-1) -= *(p+i);
                if(j > maxCount)
                    maxCount = j;
                printf("%d %d\n",*(p+i),j);
                break;
            }
            else{
                j++;
            }
        }
    }
    printf("%d\n",maxCount);

    return 0;
}

</code></pre>

<h2 id="2-10">2-10 海盗分赃</h2>
<p>题目描述：
P个海盗偷了D颗钻石后来到公海分赃，一致同意如下分赃策略：</p>
<p>首先，P个海盗通过抽签决定1-P的序号。然后由第1号海盗提出一个分配方案（方案应给出每个海盗分得的具体数量），如果能够得到包括1号在内的绝对多数（即大于半数）同意，则按照该分配方案执行，否则1号将被投入大海喂鲨鱼；而后依次类似地由第2号、第3号等等海盗提出方案，直到能够获得绝对多数同意的方案出现为止，或者只剩下最后一位海盗，其独占所有钻石。请编写一个程序，给出第1号海盗的钻石分配方案中自己分得的钻石数量。</p>
<p>附带的三个假定：</p>
<p>1) “聪明”与“贪婪”假定：每个海盗总能够以本人利益最大化作为行为准则；
2) “人性化”假定：在能够取得尽量多钻石的情况下，海盗不会故意致同伙于死地；
3) “无偏见”假定：海盗之间没有个人恩怨，分给其他海盗钻石的次序以小序号优先为原则。</p>
<p>输入格式说明：</p>
<p>输入2个正整数D和P（3&lt;=P&lt;=D&lt;=100）。</p>
<p>输出格式说明：</p>
<p>输出第1号海盗的钻石分配方案中自己分得的钻石数量。</p>
<p>样例输入与输出：</p>
<p>输入  输出  </p>
<p>10 7 6</p>
<p>3 3 2</p>
<p>100 3 99</p>
<p>100 100 49</p>
<p>题目解答：</p>
<p>这个题目其实意义不大，主要是理解题意。
当3个人时，如果第1个人被投死，那么第2个人只能讲钻石全部给最后一个人，否则自己一定会被投死，所以第一个人为了拉拢第二个人，只需给第二个人一颗钻石就好。
当4个人时，由于第二个人总有选择使自己的钻石数最多，所以他一定会投反对，因此第一个人需要拉拢第三和第四个人，他们两个在第一个人死了的情况下能得到1颗和0颗钻石，那么第一个人需要分别给他们2颗和1颗钻石才能拉拢他们投赞成票。
之后都是这样，靠前的人一定倾向于投反对票，所以要从后面的人中拉拢，要拉拢他们必须要在原来的基础上多给他们一颗钻石。
于是便能得到程序所表示的规律。</p>
<h3 id="_5">源码：</h3>
<pre><code>
#include< stdio.h>
#include< stdlib.h>

int main()
{
    int d,p;
    scanf("%d%d",&d,&p);
    if(p == 3){
        printf("%d",d-1);
    }
    else{
        printf("%d",d-(p/2+1));
    }


    return 0;
}

</code></pre>

<h2 id="2-11">2-11 两个有序链表序列的合并</h2>
<p>题目描述：</p>
<p>已知两个非降序链表序列S1与S2，设计函数构造出S1与S2的并集新非降序链表S3。</p>
<p>输入格式说明：</p>
<p>输入分2行，分别在每行给出由若干个正整数构成的非降序序列，用-1表示序列的结尾（-1不属于这个序列）。数字用空格间隔。</p>
<p>输出格式说明：</p>
<p>在一行中输出合并后新的非降序链表，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出“NULL”。</p>
<p>解答说明：</p>
<p>依次扫描两个链表，将元素值较小的那个链表指针往后移，并将较小元素值放进第三个链表中。当其中一个链表扫描完时，将另一个非空链表剩余的值直接复制到新链表中。</p>
<h3 id="_6">源码：</h3>
<pre><code>
#include"stdio.h"

typedef struct node *ptrNode;
typedef ptrNode LinkList;  //头结点
typedef ptrNode Position;//中间节点
typedef int ElementType;
struct node{
    ElementType Element;
    Position next;
};

int IsEmpty(LinkList L)
{
    return L->next == NULL;
}

LinkList creatList(void)              
{
    LinkList head,r,p;
    int x;
    head = (struct node*)malloc(sizeof(struct node));    //生成新结点
    r = head;
    scanf("%d",&x);

    while(x != -1){
        p = (struct node*)malloc(sizeof(struct node));
        p->Element = x;
        r->next = p;
        r = p;
        scanf("%d",&x);
    }
    r->next = NULL;
    return head;
}

LinkList mergeList(LinkList a, LinkList b)
{
    Position ha, hb,hc;
    LinkList c,r,p;

    ha = a->next;
    hb = b->next;

    c = (struct node*)malloc(sizeof(struct node));
    r = c;
    while((ha != NULL)&&(hb != NULL)){
        p = (struct node*)malloc(sizeof(struct node));
        if(ha->Element <= hb->Element){
            p->Element = ha->Element;
            ha = ha->next;
        }
        else{
            p->Element = hb->Element;
            hb = hb->next;
        }

        r->next = p;
        r = p;
    }
    if(ha == NULL){
        while(hb != NULL){
            p = (struct node*)malloc(sizeof(struct node));
            p->Element = hb->Element;
            hb = hb->next;
            r->next = p;
            r = p;
        }
    }
    if(hb == NULL){
        while(ha != NULL){
            p = (struct node*)malloc(sizeof(struct node));
            p->Element = ha->Element;
            ha = ha->next;
            r->next = p;
            r = p;
        }
    }

    r->next = NULL;

    return c;
}

void printList(LinkList L)
{
    LinkList hc;
    int flag = 0;

    hc = L->next;
    if(hc == NULL)
        printf("NULL");
    while(hc != NULL){
        if(flag)
            printf(" ");
        else
            flag = 1;
        printf("%d",hc->Element);
        hc = hc->next;
    }
}

int main(void)
{
    LinkList L1,L2,L3;

    L1 = creatList();
    L2 = creatList();

    L3 = mergeList(L1,L2);

    printList(L3);

    return 0;
}

</code></pre>
<section>
<p id="comment-message">Thank you for reading. Leave your comments below. </p>
<div class="accordion" id="accordion2">
    <div class="accordion-group">
        <div class="accordion-heading">
            <a class="accordion-toggle disqus-comment-count" data-toggle="collapse" data-parent="#accordion2"
                href="http://chc-fighting.github.io/wjj-1.html#disqus_thread">
                Comments
            </a>
        </div>
        <div id="disqus_thread" class="accordion-body collapse">
            <div class="accordion-inner">
                <div class="comments">
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'chcfighting';
        var disqus_identifier = 'http://chc-fighting.github.io/wjj-1.html';
    var disqus_url = 'http://chc-fighting.github.io/wjj-1.html';

    (function() {
         var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
         dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
         (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
     })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>                </div>
            </div>
        </div>
    </div>
</div>
</section>
            <aside>
            <hr/>
            <nav>
            <ul class="articles_timeline">
 
                <li class="previous_article">« <a href="http://chc-fighting.github.io/wjj-2.html" title="Previous: PAT-数据结构学习与实验指导-2">PAT-数据结构学习与实验指导-2</a></li>
            </ul>
            </nav>
            </aside>
        </div>
        <section>
        <div class="span2" style="float:right;font-size:0.9em;">
 
            <h4>Published</h4>
            <time pubdate="pubdate" datetime="2014-09-27T00:00:00">Sep 27, 2014</time>
            <h4>Category</h4>
            <a class="category-link" href="/categories.html#编程-ref">编程</a> 
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article"> 
                <li><a href="/tags.html#PAT-编程-数据结构-C语言-ref">PAT 编程 数据结构 C语言
                    <span>2</span>
</a></li>
            </ul>

        </div>
        </section>
</div>
</article>
                </div>
                <div class="span1"></div>
            </div>
        </div>
    </div>
<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="http://oncrashreboot.com/pelican-elegant" title="Theme Elegant Home Page">Elegant</a> by <a href="http://oncrashreboot.com" title="Talha Mansoor Home Page">Talha Mansoor</a></li>
    </ul>
</div>
</footer>            <script src="http://code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/js/bootstrap.min.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

<script type="text/javascript">
    var disqus_shortname = 'chcfighting';

    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
    </script>
        <script  language="javascript" type="text/javascript">
            function uncollapse() {
                var hash_str = window.location.hash;
                if (window.location.hash.match(/^#comment-\d+$/))
                {
                    var hash_str = '#disqus_thread';
                }
                $(hash_str).collapse({
                    toggle: true
                    })
            }
        </script>

        <script type="text/javascript" language="JavaScript">
            uncollapse(); 
        </script>
    </body>
</html>